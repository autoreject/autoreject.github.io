

.. _sphx_glr_auto_examples_plot_auto_repair.py:


===========================
Automatically repair epochs
===========================

This example demonstrates how to use :mod:`autoreject` to automatically
repair epochs.


.. code-block:: python


    # Author: Mainak Jas <mainak.jas@telecom-paristech.fr>
    # License: BSD (3-clause)







Let us first define the parameters. `n_interpolates` are the :math:`\rho`
values that we would like :mod:`autoreject` to try and `consensus_percs`
are the :math:`\kappa` values that :mod:`autoreject` will try.

Epochs with more than :math:`\kappa * N` sensors (:math:`N` total sensors)
bad are dropped. For the rest of the epochs, the worst :math:`\rho`
bad sensors (as determined by channel-level thresholds) are interpolated.
The exact values of these parameters are not preselected but learned from
the data. If the number of bad sensors for a particular trial is less than
:math:`\rho`, all the bad sensors are interpolated.


.. code-block:: python

    import numpy as np

    n_interpolates = np.array([1, 4, 32])
    consensus_percs = np.linspace(0, 1.0, 11)







For the purposes of this example, we shall use the MNE sample dataset.
Therefore, let us make some MNE related imports.


.. code-block:: python


    import mne  # noqa
    from mne.utils import check_random_state  # noqa
    from mne.datasets import sample  # noqa







Now, we can import the class required for rejecting and repairing bad
epochs. :func:`autoreject.compute_thresholds` is a callable which must be
provided to the :class:`autoreject.LocalAutoRejectCV` class for computing
the channel-level thresholds.


.. code-block:: python


    from autoreject import (LocalAutoRejectCV, compute_thresholds,
                            set_matplotlib_defaults)  # noqa







Let us now read in the raw `fif` file for MNE sample dataset.


.. code-block:: python


    check_random_state(42)

    data_path = sample.data_path()
    raw_fname = data_path + '/MEG/sample/sample_audvis_filt-0-40_raw.fif'
    raw = mne.io.read_raw_fif(raw_fname, preload=True)





.. rst-class:: sphx-glr-script-out

 Out::

      Opening raw data file /home/mainak/Desktop/projects/github_repos/mne-python/examples/MNE-sample-data/MEG/sample/sample_audvis_filt-0-40_raw.fif...
        Read a total of 4 projection items:
            PCA-v1 (1 x 102)  idle
            PCA-v2 (1 x 102)  idle
            PCA-v3 (1 x 102)  idle
            Average EEG reference (1 x 60)  idle
        Range : 6450 ... 48149 =     42.956 ...   320.665 secs
    Ready.
    Current compensation grade : 0
    Reading 0 ... 41699  =      0.000 ...   277.709 secs...


We can then read in the events


.. code-block:: python


    event_fname = data_path + ('/MEG/sample/sample_audvis_filt-0-40_raw-'
                               'eve.fif')
    event_id = {'Auditory/Left': 1}
    tmin, tmax = -0.2, 0.5

    events = mne.read_events(event_fname)







And pick MEG channels for repairing. Currently, :mod:`autoreject` can repair
only one channel type at a time.


.. code-block:: python


    raw.info['bads'] = []
    picks = mne.pick_types(raw.info, meg='grad', eeg=False, stim=False, eog=False,
                           include=[], exclude=[])







Now, we can create epochs. The ``reject`` params will be set to ``None``
because we do not want epochs to be dropped when instantiating
:class:`mne.Epochs`.


.. code-block:: python


    raw.info['projs'] = list()  # remove proj, don't proj while interpolating
    epochs = mne.Epochs(raw, events, event_id, tmin, tmax,
                        picks=picks, baseline=(None, 0), reject=None,
                        verbose=False, detrend=0, preload=True)







First, we set up the function to compute the sensor-level thresholds.


.. code-block:: python


    from functools import partial  # noqa
    thresh_func = partial(compute_thresholds, method='random_search',
                          random_state=42)







:class:`autoreject.LocalAutoRejectCV` internally does cross-validation to
determine the optimal values :math:`\rho^{*}` and :math:`\kappa^{*}`


.. code-block:: python


    ar = LocalAutoRejectCV(n_interpolates, consensus_percs,
                           thresh_func=thresh_func)
    epochs_clean = ar.fit_transform(epochs)

    evoked = epochs.average()
    evoked_clean = epochs_clean.average()





.. rst-class:: sphx-glr-script-out

 Out::

      [                                        ] 0.49020 | Creating augmented epochs       [                                        ] 0.49020 | Computing thresholds       [                                        ] 1.38889 | Repairing epochs       [....                                    ] 10.00000 | Fold       [                                        ] 1.38889 | Repairing epochs       [....                                    ] 10.00000 | Fold       [                                        ] 1.38889 | Repairing epochs       [....                                    ] 10.00000 | Fold       [.............                           ] 33.33333 | n_interp   Estimated consensus_perc=0.30 and n_interpolate=32
    [                                        ] 1.38889 | Repairing epochs


Now, we will manually mark the bad channels just for plotting.


.. code-block:: python


    evoked.info['bads'] = ['MEG 2443']
    evoked_clean.info['bads'] = ['MEG 2443']







Let us plot the results.


.. code-block:: python


    import matplotlib.pyplot as plt  # noqa
    set_matplotlib_defaults(plt)

    fig, axes = plt.subplots(2, 1, figsize=(6, 6))

    for ax in axes:
        ax.tick_params(axis='x', which='both', bottom='off', top='off')
        ax.tick_params(axis='y', which='both', left='off', right='off')

    ylim = dict(grad=(-170, 200))
    evoked.pick_types(meg='grad', exclude=[])
    evoked.plot(exclude=[], axes=axes[0], ylim=ylim, show=False)
    axes[0].set_title('Before autoreject')
    evoked_clean.pick_types(meg='grad', exclude=[])
    evoked_clean.plot(exclude=[], axes=axes[1], ylim=ylim)
    axes[1].set_title('After autoreject')
    plt.tight_layout()




.. image:: /auto_examples/images/sphx_glr_plot_auto_repair_001.png
    :align: center




To top things up, we can also visualize the bad sensors for each trial using
a heatmap.


.. code-block:: python


    set_matplotlib_defaults(plt)

    plt.figure(figsize=(12, 6))
    im = plt.imshow(ar.bad_segments, cmap='Reds', interpolation='nearest')
    ax = im.get_axes()
    ax.grid(False)
    ax.set_xlabel('Sensors')
    ax.set_ylabel('Trials')
    plt.setp(ax, xticks=range(7, epochs.info['nchan'], 10),
             xticklabels=epochs.info['ch_names'][7::10])
    plt.setp(ax.get_yticklabels(), rotation=0)
    plt.setp(ax.get_xticklabels(), rotation=90)
    ax.tick_params(axis=u'both', which=u'both', length=0)
    plt.tight_layout(rect=[None, None, None, 1.1])
    plt.show()



.. image:: /auto_examples/images/sphx_glr_plot_auto_repair_002.png
    :align: center




**Total running time of the script:**
(2 minutes 15.781 seconds)



.. container:: sphx-glr-download

    **Download Python source code:** :download:`plot_auto_repair.py <plot_auto_repair.py>`


.. container:: sphx-glr-download

    **Download IPython notebook:** :download:`plot_auto_repair.ipynb <plot_auto_repair.ipynb>`
