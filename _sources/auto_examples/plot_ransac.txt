

.. _sphx_glr_auto_examples_plot_ransac.py:


===============================
Detect bad sensors using RANSAC
===============================

This example demonstrates how to use RANSAC [1] from the PREP pipeline to
detect bad sensors and repair them. Note that this implementation in
:mod:`autoreject` [2] is an extension of the original implementation and
works for MEG sensors as well.

[1] Bigdely-Shamlo, Nima, et al.
    "The PREP pipeline: standardized preprocessing for large-scale EEG
    analysis." Frontiers in neuroinformatics 9 (2015).
[2] Mainak Jas, Denis Engemann, Yousra Bekhti, Federico Raimondo, and Alexandre Gramfort,
    "Autoreject: Automated artifact rejection for MEG and EEG." arXiv preprint
    arXiv:1612.08194, 2016.


.. code-block:: python


    # Author: Mainak Jas <mainak.jas@telecom-paristech.fr>
    # License: BSD (3-clause)







For the purposes of this example, we shall use the MNE sample dataset.
Therefore, let us make some MNE related imports.


.. code-block:: python


    import mne
    from mne import io
    from mne import Epochs
    from mne.datasets import sample







Let us now read in the raw `fif` file for MNE sample dataset.


.. code-block:: python


    data_path = sample.data_path()
    raw_fname = data_path + '/MEG/sample/sample_audvis_filt-0-40_raw.fif'
    raw = io.read_raw_fif(raw_fname, preload=True)





.. rst-class:: sphx-glr-script-out

 Out::

      Opening raw data file /home/mainak/Desktop/projects/github_repos/mne-python/examples/MNE-sample-data/MEG/sample/sample_audvis_filt-0-40_raw.fif...
        Read a total of 4 projection items:
            PCA-v1 (1 x 102)  idle
            PCA-v2 (1 x 102)  idle
            PCA-v3 (1 x 102)  idle
            Average EEG reference (1 x 60)  idle
        Range : 6450 ... 48149 =     42.956 ...   320.665 secs
    Ready.
    Current compensation grade : 0
    Reading 0 ... 41699  =      0.000 ...   277.709 secs...


We can then read in the events


.. code-block:: python


    event_fname = data_path + ('/MEG/sample/sample_audvis_filt-0-40_raw-'
                               'eve.fif')
    event_id = {'Auditory/Left': 1}
    tmin, tmax = -0.2, 0.5

    events = mne.read_events(event_fname)







And pick MEG channels for repairing. Currently, :mod:`autoreject` can repair
only one channel type at a time.


.. code-block:: python


    raw.info['bads'] = []
    picks = mne.pick_types(raw.info, meg='grad', eeg=False, stim=False, eog=False,
                           include=[], exclude=[])







Now, we can create epochs. The ``reject`` params will be set to ``None``
because we do not want epochs to be dropped when instantiating
:class:`mne.Epochs`.


.. code-block:: python


    raw.info['projs'] = list()  # remove proj, don't proj while interpolating
    epochs = Epochs(raw, events, event_id, tmin, tmax,
                    picks=picks, baseline=(None, 0), reject=None,
                    verbose=False, detrend=0, preload=True)







We import ``Ransac`` and run the familiar ``fit_transform`` method.


.. code-block:: python

    from autoreject import Ransac
    from autoreject.utils import interpolate_bads

    ransac = Ransac(ch_type='meg', verbose='tqdm')
    epochs_clean = ransac.fit_transform(epochs)





.. rst-class:: sphx-glr-script-out

 Out::

      Computing dot products for 183 coils...
        Computing cross products for coils 183 x 21 coils...
        Preparing the mapping matrix...
        [Truncate at 77 missing 0.0001]


We can also get the list of bad channels computed by ``Ransac``.


.. code-block:: python


    print('\n'.join(ransac.bad_chs_))





.. rst-class:: sphx-glr-script-out

 Out::

      MEG 0512
    MEG 0523
    MEG 0613
    MEG 0722
    MEG 0813
    MEG 0823
    MEG 0912
    MEG 0942
    MEG 0943
    MEG 1013
    MEG 1023
    MEG 1032
    MEG 1033
    MEG 1832
    MEG 1842
    MEG 2023
    MEG 2242
    MEG 2312
    MEG 2432
    MEG 2443
    MEG 2523


Then we compute the ``evoked`` before and after interpolation.


.. code-block:: python


    evoked = epochs.average()
    evoked_clean = epochs_clean.average()







We will manually mark the bad channels just for plotting.


.. code-block:: python


    evoked.info['bads'] = ['MEG 2443']
    evoked_clean.info['bads'] = ['MEG 2443']







Let us plot the results.


.. code-block:: python


    from autoreject.utils import set_matplotlib_defaults
    import matplotlib.pyplot as plt
    set_matplotlib_defaults(plt)

    fig, axes = plt.subplots(2, 1, figsize=(6, 6))

    for ax in axes:
        ax.tick_params(axis='x', which='both', bottom='off', top='off')
        ax.tick_params(axis='y', which='both', left='off', right='off')

    ylim = dict(grad=(-170, 200))
    evoked.pick_types(meg='grad', exclude=[])
    evoked.plot(exclude=[], axes=axes[0], ylim=ylim, show=False)
    axes[0].set_title('Before RANSAC')
    evoked_clean.pick_types(meg='grad', exclude=[])
    evoked_clean.plot(exclude=[], axes=axes[1], ylim=ylim)
    axes[1].set_title('After RANSAC')
    plt.tight_layout()




.. image:: /auto_examples/images/sphx_glr_plot_ransac_001.png
    :align: center




To top things up, we can also visualize the bad sensors for each trial using
:func:`seaborn.heatmap`.


.. code-block:: python

    import seaborn as sns
    set_matplotlib_defaults(plt)

    plt.figure(figsize=(18, 6))
    ax = sns.heatmap(ransac.bad_log, yticklabels=20, square=True,
                     cbar=False, cmap='Reds')
    ax.set_xlabel('Sensors')
    ax.set_ylabel('Trials')

    plt.setp(ax, xticks=ax.get_xticks()[::10],
             xticklabels=epochs.info['ch_names'][::10])
    plt.setp(ax.get_yticklabels(), rotation=0)
    plt.setp(ax.get_xticklabels(), rotation=90)
    plt.tight_layout(rect=[None, None, None, 1.1])
    plt.show()



.. image:: /auto_examples/images/sphx_glr_plot_ransac_002.png
    :align: center




**Total running time of the script:**
(0 minutes 14.262 seconds)



.. container:: sphx-glr-download

    **Download Python source code:** :download:`plot_ransac.py <plot_ransac.py>`


.. container:: sphx-glr-download

    **Download IPython notebook:** :download:`plot_ransac.ipynb <plot_ransac.ipynb>`
